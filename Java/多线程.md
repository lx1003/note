## 为什么要使用多线程

- 从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，减少了线程上下文切换的开销
- 从当代互联网发展趋势来说：现在的系统动不动就要求百万级甚至千万级的并发量。而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能

## 上下文切换

多线程编程中一般线程的个数都大于CPU核心的个数，而一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU采取的策略是为每个线程分配时间片轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换

当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个人物的状态。任务从保存到再加载的过程就是一次上下文切换

## sleep()和wait()区别与共同点

- 两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁
- 两者都可以暂停线程的执行
- Wait通常被用于线程间交互/通信，sleep通常被用于暂停放行
- wait方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()。sleep方法执行后，线程会自动苏醒。或者可以使用wait超时后线程会自动苏醒

## 为什么调用start()会执行run()，为什么不能直接调用run()

new一个Thread，线程进入了新建状态；调用start方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start会执行线程的相应准备工作，然后自动执行run方法的内容，这是真正的多线程工作。而直接执行run方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它

调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法的调用，还是在主线程里执行

## synchronized关键字

synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行

## synchronized关键字最主要的三种使用方式

- 修饰实例方法：作用域当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
- 修饰静态方法：就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁
- 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

------

线程安全：指在并发的情况下，该代码经过多线程使用，线程的调度顺序不影响任何结果，这个时候使用多线程，只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果

同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确，在保证结果准确的同时，提高性能。线程安全的优先级高于性能