## 继承

使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能、也可以用父类的功能，但不能选择性地继承父类

1. 子类拥有父类对象所有的属性和方法，但父类中的私有属性和方法子类是无法访问的，只是拥有
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
3. 子类可以用自己的方式实现父类的方法

## 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时期不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定

在Java中有两种形式可以实现多态：继承和接口

## String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?  

String类中使用final关键字修饰字符数组来保存字符串

StringBuilder与StringBuffer都继承自AbstractStringBuilder类

String中的对象是不可变的，也就可以理解为常量，线程安全。

StringBuilder对方法加了同步锁或者对调用得方法加了同步锁，所以是线程安全的。StringBuillder并没有对方加同步锁，所以是非线程安全的

推荐使用StringBuffer

1. 操作少量得数据：适用String
2. 单线程操作字符串缓冲区下操作大量数据：StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer

## 自动拆箱与装箱

- 将基本类型用它们对应得引用类型包装起来
- 将包装类型转换为基本数据类型

## 在一个静态方法内调用一个非静态成员为什么是非法的

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员

## 无参构造得作用

Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定得构造方法，则会调用父类中“没有参数得构造方法”。因此，如果父类中只定义了有参数得构造方法，而在子类的构造方法中又没有super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数得构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数得构造方法

## 接口和抽象类的区别是什么

1. 接口的方法默认是public，所有方法在接口中不能有实现，而抽象类可以有非抽象的方法
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范

## 成员变量与局部变量的区别有哪些

1. 从语法形式上看：成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数
2. 从变量的内存中s的存储方式来看：如果成员变量是是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存
3. 从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在，

## HashCode与equals

hashCode()的作用是获取哈希码，也称为给散列码，实际返回一个int整数。作用是确定该对象在哈希表中的索引位置。hashCode定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode函数

散列表存储的是键值对（key-value），特点是：能根据“键”快速的检索出对应的“值”这其中就利用到了散列码

## 为什么要有hashCode

hashCode()的作用就是获取哈希码，也称为散列码；实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其他情况下没用。在散列表中hashCode的作用是获取对象的散列码，进而确定该对象在散列表中的位置

## hashCode()与equals的相关规定

1. 如果两个对象相等，则hashCode一定也是相等的
2. 两个对象相等，对两个对象分别调用equals方法都返回true
3. 两个对象有相同的hashCode值，不一定相等
4. equals方法被覆盖过，hashCode方法也必须被覆盖
5. hashCode的默认行为是对堆上的对象产生独特值。如果没有重写hashCode，则该class的两个对象无论如何都不会相等

## Java反序列化

transient：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法

## Java中IO流分为几种

- 按照流的流向分，可以分为输入流和输出流
- 按照操作单元划分，可以分为字节流和字符流
- 按照流的角色划分为节点流和处理流

4个抽象类基类中派生出来的

- InputStream/Reader：所有的输入流的基类，前者是字节输入流，后者是字符输入流
- OutputStream/Writer：输出流的基类，字节输出流/字符输出流

![image-20200413111806270](C:\Users\XN\AppData\Roaming\Typora\typora-user-images\image-20200413111806270.png)

![image-20200413111906530](C:\Users\XN\AppData\Roaming\Typora\typora-user-images\image-20200413111906530.png)

不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么I/O流操作要分为字节流操作和字符流操作呢

字符流是Java虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，I/O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果设计到字符的话使用字符流比较好

